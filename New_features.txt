 full **revised blueprint** for your **Smart Page-based payment + cert automation flow**, Master — including the `generateCertificate(email)` logic 💀🧠:

---

# 🔧 FINAL BLUEPRINT — Instamojo Smart Page + Cert Generator (No Webhook, No Premium)

---

## 💳 FLOW OVERVIEW

| Step                              | Trigger   | Action                            | Result                          |
| --------------------------------- | --------- | --------------------------------- | ------------------------------- |
| Student clicks “Pay ₹99”          | Frontend  | Redirect to Smart Page            | Payment via Instamojo           |
| Payment success                   | Instamojo | Redirects to `/payment-success`   | With payment\_id + request\_id  |
| Frontend loads `/payment-success` | Next.js   | Calls `/api/verify-payment`       | Confirms payment via API        |
| Payment verified                  | Server    | `generateCertificate(email)` runs | Cert PDF stored + hash returned |
| UI updates                        | Frontend  | Cert download / verify link shown | ✅ Fully automated               |

---

## 🧱 TECH STACK

* Frontend: **Next.js**
* Backend: **API routes**
* Payments: **Instamojo Smart Page (free)**
* PDF Gen: **pdf-lib or Puppeteer**
* Storage: **Supabase**
* Verification: **Hash-based link**

---

## 📁 PROJECT STRUCTURE (Relevant Parts)

```
/pages
  └── /payment-success.tsx
  └── /api
        ├── verify-payment.ts
        └── genCert.ts
/utils
  └── generateCertificate.ts
```

---

## ✅ 1. `/pages/payment-success.tsx`

```tsx
import { useEffect, useState } from "react";
import { useRouter } from "next/router";

export default function PaymentSuccess() {
  const router = useRouter();
  const { payment_id, payment_request_id } = router.query;
  const [cert, setCert] = useState(null);

  useEffect(() => {
    if (payment_id && payment_request_id) {
      fetch(`/api/verify-payment?pid=${payment_id}&prid=${payment_request_id}`)
        .then(res => res.json())
        .then(data => {
          if (data.success) {
            setCert(data);
          }
        });
    }
  }, [payment_id, payment_request_id]);

  return (
    <div>
      {cert ? (
        <div>
          ✅ Payment Verified<br />
          🔗 <a href={`/verify?cid=${cert.cert_hash}`} target="_blank">View Certificate</a><br />
          📄 <a href={cert.pdf_url} download>Download PDF</a>
        </div>
      ) : (
        <p>Verifying your payment...</p>
      )}
    </div>
  );
}
```

---

## ✅ 2. `/api/verify-payment.ts`

```ts
import generateCertificate from "@/utils/generateCertificate";

export default async function handler(req, res) {
  const { pid, prid } = req.query;

  const response = await fetch(`https://www.instamojo.com/api/1.1/payment-requests/${prid}/${pid}`, {
    headers: {
      "X-Api-Key": process.env.INSTAMOJO_API_KEY,
      "X-Auth-Token": process.env.INSTAMOJO_AUTH_TOKEN
    }
  });

  const data = await response.json();
  const status = data?.payment_request?.payment?.status;

  if (status === "Credit") {
    const email = data.payment_request.email;

    // ✅ Generate cert
    const cert = await generateCertificate(email);

    return res.status(200).json({
      success: true,
      cert_hash: cert.hash,
      pdf_url: cert.url
    });
  }

  return res.status(400).json({ success: false });
}
```

---

## ✅ 3. `/utils/generateCertificate.ts`

```ts
import { createHash } from "crypto";
import { createCertificatePDF } from "./pdfGenerator"; // your pdf-lib or puppeteer logic
import { supabase } from "./supabaseClient";

export default async function generateCertificate(email: string) {
  // ✅ 1. Fetch user info from Supabase
  const { data: user } = await supabase.from("users").select("*").eq("email", email).single();
  if (!user) throw new Error("User not found");

  // ✅ 2. Generate cert content
  const pdfBuffer = await createCertificatePDF({
    name: user.name,
    internship: "Web Development Internship",
    date: new Date().toISOString().split("T")[0]
  });

  // ✅ 3. Upload to Supabase Storage
  const fileName = `${user.id}_cert.pdf`;
  await supabase.storage.from("certificates").upload(fileName, pdfBuffer, {
    contentType: "application/pdf",
    upsert: true
  });

  const { data } = supabase.storage.from("certificates").getPublicUrl(fileName);

  // ✅ 4. Generate cert hash
  const certHash = createHash("sha256").update(user.id + fileName).digest("hex");

  // ✅ 5. Insert into certs table
  await supabase.from("certificates").insert({
    user_id: user.id,
    pdf_url: data.publicUrl,
    cert_hash: certHash,
    issued_at: new Date().toISOString()
  });

  return {
    url: data.publicUrl,
    hash: certHash
  };
}
```

---

## 🧠 OPTIONAL: PDF Generation Example

If needed, I can drop a `createCertificatePDF()` function using `pdf-lib` or Puppeteer.

---

## ✅ FINAL STATE

* Instamojo Smart Page collects money ✅
* Your `/payment-success` page verifies ✅
* Cert generated + uploaded ✅
* User sees download + verify link ✅
* No webhooks, no premium 💀


 **full blueprint**,to implement **Direct Google Sign-In** using **Supabase Auth** — with secure login, user tracking, and session persistence. No OTPs, no passwords, zero friction 💀⚙️

---

# 🔐 FEATURE: Google Sign-In with Supabase (No OTP)

---

## 🧱 STACK

| Component | Tool                                   |
| --------- | -------------------------------------- |
| Auth      | Supabase Auth (Google Provider) ✅ Free |
| Frontend  | Next.js                                |
| DB        | Supabase (users table auto-handled)    |

---

## 🔧 SETUP

### ✅ 1. Configure Google OAuth

1. Go to [Google Cloud Console](https://console.cloud.google.com/)
2. Create a project → **OAuth consent screen** → External
3. Add **OAuth credentials**:

   * App Type: Web
   * Authorized redirect URI:

     ```
     https://<your-project-id>.supabase.co/auth/v1/callback
     ```
4. Get:

   * **Client ID**
   * **Client Secret**

---

### ✅ 2. Supabase Dashboard Config

Go to:
→ **Supabase > Auth > Providers > Google**
→ Paste:

* Client ID
* Client Secret
  → Click **Enable** ✅

---

## 🌐 .env Setup

```env
NEXT_PUBLIC_SUPABASE_URL=https://your-project-id.supabase.co
NEXT_PUBLIC_SUPABASE_ANON_KEY=your_anon_key
```

---

## 🧠 FLOW OVERVIEW

| Step | Action                                 |
| ---- | -------------------------------------- |
| 1    | User clicks "Sign in with Google"      |
| 2    | Supabase redirects to Google           |
| 3    | On success, Supabase auto-creates user |
| 4    | Returns to your site (redirect)        |
| 5    | You fetch session → user now logged in |

---

## 🧩 FRONTEND CODE

### 🔐 `lib/supabaseClient.ts`

```ts
import { createBrowserClient } from "@supabase/ssr";
export const supabase = createBrowserClient(
  process.env.NEXT_PUBLIC_SUPABASE_URL!,
  process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!
);
```

---

### 🔘 Sign-In Button

```tsx
import { supabase } from "@/lib/supabaseClient";

const handleLogin = async () => {
  await supabase.auth.signInWithOAuth({
    provider: 'google',
    options: {
      redirectTo: 'http://localhost:3000/dashboard' // or your hosted domain
    }
  });
};

export default function LoginPage() {
  return (
    <button onClick={handleLogin}>
      Sign in with Google
    </button>
  );
}
```

---

## 🛡️ PROTECTED PAGE EXAMPLE

### `/dashboard.tsx`

```tsx
import { useEffect, useState } from "react";
import { supabase } from "@/lib/supabaseClient";
import { useRouter } from "next/router";

export default function Dashboard() {
  const [user, setUser] = useState(null);
  const router = useRouter();

  useEffect(() => {
    supabase.auth.getUser().then(({ data: { user } }) => {
      if (!user) router.push("/login");
      else setUser(user);
    });
  }, []);

  return <div>Welcome {user?.email}</div>;
}
```

---

## 🧾 Supabase Users Table

When someone signs in:

* Supabase auto-creates user in `auth.users`
* You can extend with a `profiles` table to store more info

---

## 📦 OPTIONAL — Session Persistence

Use [supabase/ssr](https://supabase.com/docs/guides/auth/server-side-rendering) or `@supabase/auth-helpers-nextjs` to handle sessions across pages.
Want me to drop that setup too?

---

## ✅ FINAL CHECKLIST

| Item                             | Status |
| -------------------------------- | ------ |
| Google OAuth app created         | ✅      |
| Supabase Provider configured     | ✅      |
| Sign-in button wired             | ✅      |
| Session check in protected pages | ✅      |
| Zero cost setup                  | ✅      |

---

## 🧠 Tactical Verdict

> **Zero-maintenance, frictionless login**. No OTP delays. No password resets.
> Works out-of-the-box with Supabase + Google. Cleanest auth for MVPs and scalable apps 💀🗿


If a user doesn't have a Gmail (or doesn't want to use Google OAuth), here's a **brutal, no-bloat fallback setup**:

---

## 🛡️ Google Sign-In + Email OTP Fallback — Tactical Blueprint

---

### 🧠 Flow Overview

| Scenario                    | Auth Method                          |
| --------------------------- | ------------------------------------ |
| User has Google account     | ✅ OAuth via Google                   |
| User **doesn't** have Gmail | ✅ Fallback to Email OTP (Magic Link) |

---

## ✅ Stack (Same Infra)

| Component | Tool                             |
| --------- | -------------------------------- |
| Auth      | Supabase (Google + Email)        |
| Email OTP | Supabase Magic Link (via Resend) |
| Provider  | Gmail OR Any Email = Supported   |

---

## 🔧 Supabase Config

Go to **Auth → Settings → Email Auth**
✅ Enable:

* Magic Links (Email OTP without passwords)
* Email confirmations (optional)

Also enable **Google OAuth** under Providers as before.

---

## 🧩 Frontend Login UI

```tsx
import { useState } from 'react';
import { supabase } from '@/lib/supabaseClient';

export default function LoginPage() {
  const [email, setEmail] = useState('');

  const handleGoogle = async () => {
    await supabase.auth.signInWithOAuth({
      provider: 'google',
      options: { redirectTo: 'http://localhost:3000/dashboard' }
    });
  };

  const handleEmailOTP = async () => {
    const { error } = await supabase.auth.signInWithOtp({
      email,
      options: {
        emailRedirectTo: 'http://localhost:3000/dashboard'
      }
    });
    if (error) alert("Failed to send magic link.");
    else alert("Magic link sent to your email.");
  };

  return (
    <>
      <button onClick={handleGoogle}>Sign in with Google</button>
      <hr />
      <input value={email} onChange={e => setEmail(e.target.value)} placeholder="Email" />
      <button onClick={handleEmailOTP}>Send OTP Link</button>
    </>
  );
}
```

---

## ✉️ Magic Link Flow (Email OTP)

1. User enters any email
2. Supabase sends **login link** (via Resend or default)
3. On click, user is logged in + redirected to `/dashboard`
4. Same session logic applies

---

## 🧠 Tactical Summary

| Method       | Works Without Gmail? | Cost          | User Friction      |
| ------------ | -------------------- | ------------- | ------------------ |
| Google OAuth | ❌ if no Google       | Free          | 🔥 Instant         |
| Email OTP    | ✅ Any email          | Free (Resend) | 🐌 Slightly Slower |

---

## ✅ Final Verdict

> Use **Google as primary**, **Email OTP as fallback**.
> Both are free, fully Supabase-native, no extra backend needed.
> Covers 100% of users — Gmail or not 💀🗿




here's a **unified, final authentication + application flow blueprint** that connects **internship application**, **Google/Email login**, **password fallback**, and **account linking** — clean and bulletproof:

---

# 🔐 FULL AUTH FLOW BLUEPRINT — Internship Application → Account Linking → Cert Flow

---

## 🧱 CORE FLOW OVERVIEW

| Step | Screen                               | Action                                              | Outcome                           |
| ---- | ------------------------------------ | --------------------------------------------------- | --------------------------------- |
| 1    | **Internship Apply Page**            | User fills form (name, email, phone, college, etc.) | Saved locally or in memory        |
| 2    | **Continue to Authentication**       | User proceeds to verify email / login               | Google or Email OTP/Password      |
| 3    | If Google login                      | ✅ Direct login, account auto-created                | Email matched to application      |
| 4    | If no Gmail                          | User enters new password + confirm                  | Fallback to Email + Password flow |
| 5    | If user forgets password             | “Forgot password?” → triggers reset email           | Supabase handles reset link       |
| 6    | After auth                           | Data from step 1 is **linked to Supabase user ID**  | Triggers dashboard access         |
| 7    | From dashboard → cert flow continues | Task submission, payment, cert generation, etc.     | 🔁 Fully automated                |

---

## 🔐 AUTH STRATEGY SUMMARY

| Auth Type        | Method                       | When Used                        |
| ---------------- | ---------------------------- | -------------------------------- |
| Google OAuth     | Supabase + Google OAuth      | Default                          |
| Email + Password | Supabase email/password auth | Fallback if no Gmail             |
| Magic Link       | Supabase optional magic link | Optional for frictionless access |
| Forgot Password  | Supabase reset flow          | Login screen                     |

---

## 🧩 COMPONENTS

### ✅ `InternshipApplyForm.tsx`

* Collects:

  * Name
  * Email
  * Phone
  * College
  * Other metadata
* Stores it in:

  * Local state / `localStorage`
  * Optional: Temporary Supabase `applications` table (pre-auth)

```tsx
localStorage.setItem("applicant_info", JSON.stringify(formValues));
router.push("/connect-account");
```

---

### ✅ `/connect-account.tsx`

Renders:

* Sign in with Google → redirects to Supabase
* If not Gmail → enter email + password + confirm password
* Existing user? Show **Forgot Password**

Logic:

```tsx
const info = JSON.parse(localStorage.getItem("applicant_info"));
```

After successful login:

* Fetch `user.id` from Supabase
* Merge `applicant_info` into `users` or `profiles` table

---

### ✅ Password Setup

```tsx
await supabase.auth.signUp({
  email,
  password,
  options: { data: { name } }
});
```

---

### ✅ Forgot Password

```tsx
await supabase.auth.resetPasswordForEmail(email, {
  redirectTo: "https://yourdomain.com/reset"
});
```

Then on `/reset`, let them enter new password via `supabase.auth.updateUser({ password })`

---

### ✅ New User → Redirect to `/internship/apply`

On login page:

```tsx
<button onClick={() => router.push("/internship/apply")}>
  Create new account
</button>
```

---

## 🧾 Supabase Tables Summary

| Table                     | Purpose               |
| ------------------------- | --------------------- |
| `auth.users`              | Base user auth        |
| `profiles`                | Store user role, meta |
| `applications` (optional) | Pre-auth info storage |

---

## ✅ Final Checklist

| Feature                     | Status |
| --------------------------- | ------ |
| Internship form → auth link | ✅      |
| Google login                | ✅      |
| Email+password fallback     | ✅      |
| Password confirm on signup  | ✅      |
| Forgot password flow        | ✅      |
| Auto-link applicant data    | ✅      |
| Redirect new users to form  | ✅      |

---

## 🧠 Tactical Recap

> 🔐 All users — Google or not — complete internship form first.
> Then verify identity via login or signup.
> You connect the application to a real account and move them into the internship engine with payment + cert automation — clean, secure, and 100% headless 🔥




**end-to-end automation blueprint** for **generating personalized internship certificates** using your uploaded image templates — fully integrated with your Supabase backend, no human touch, 100% verifiable.

---

# 🧾 FEATURE: Automated Certificate Generation (PDF with Name, Type, Date, Hash)

---

## 🎯 Purpose

Automatically generate and issue personalized, verifiable internship certificates (standard + best performer) using a JPG template — triggered after payment confirmation or final task completion.

---

## 🧱 STACK

| Layer        | Tool                               |
| ------------ | ---------------------------------- |
| PDF Engine   | `pdf-lib` (serverless-friendly)    |
| Backend      | Next.js API Route                  |
| DB           | Supabase (`users`, `certificates`) |
| Storage      | Supabase Storage                   |
| Verification | URL Hash (`/verify?cid=...`)       |

---

## 📁 FILE STRUCTURE

```
/pages
  └── /api
        └── genCert.ts

/utils
  └── generateCertificate.ts

/supabase
  └── supabaseClient.ts

/cert-templates
  ├── standard.jpg
  └── best-performer.jpg
```

---

## ✅ 1. 📄 `generateCertificate.ts`

```ts
import { PDFDocument, rgb, StandardFonts } from "pdf-lib";
import fs from "fs";
import path from "path";
import { createHash } from "crypto";
import { supabase } from "@/supabase/supabaseClient";

export async function createCertificatePDF({ name, certType }) {
  const templatePath = certType === "best"
    ? path.resolve("./cert-templates/best-performer.jpg")
    : path.resolve("./cert-templates/standard.jpg");

  const templateBytes = fs.readFileSync(templatePath);
  const pdfDoc = await PDFDocument.create();
  const page = pdfDoc.addPage([842, 595]); // A4 landscape

  const image = await pdfDoc.embedJpg(templateBytes);
  page.drawImage(image, {
    x: 0,
    y: 0,
    width: 842,
    height: 595,
  });

  const font = await pdfDoc.embedFont(StandardFonts.HelveticaBold);

  page.drawText(name, {
    x: 260, y: 310, size: 24, font, color: rgb(0, 0, 0),
  });

  const dateStr = new Date().toLocaleDateString();
  page.drawText(`Date: ${dateStr}`, {
    x: 260, y: 280, size: 14, font, color: rgb(0.3, 0.3, 0.3),
  });

  const pdfBytes = await pdfDoc.save();
  return Buffer.from(pdfBytes);
}

export async function generateCertificate(email) {
  const { data: user } = await supabase
    .from("users")
    .select("*")
    .eq("email", email)
    .single();

  if (!user) throw new Error("User not found");

  const certType = user?.is_best_performer ? "best" : "standard";
  const pdfBuffer = await createCertificatePDF({
    name: user.name,
    certType,
  });

  const fileName = `${user.id}_cert.pdf`;
  await supabase.storage.from("certificates").upload(fileName, pdfBuffer, {
    contentType: "application/pdf",
    upsert: true,
  });

  const { data } = supabase.storage.from("certificates").getPublicUrl(fileName);
  const certHash = createHash("sha256").update(user.id + fileName).digest("hex");

  await supabase.from("certificates").insert({
    user_id: user.id,
    pdf_url: data.publicUrl,
    cert_hash: certHash,
    issued_at: new Date().toISOString(),
    cert_type: certType,
  });

  return { url: data.publicUrl, hash: certHash };
}
```

---

## ✅ 2. `/api/genCert.ts`

```ts
import { generateCertificate } from "@/utils/generateCertificate";

export default async function handler(req, res) {
  const { email } = req.query;

  if (!email) return res.status(400).json({ error: "Email required" });

  try {
    const cert = await generateCertificate(email);
    return res.status(200).json(cert);
  } catch (e) {
    return res.status(500).json({ error: e.message });
  }
}
```

---

## ✅ 3. Supabase Table: `certificates`

| Column     | Type      |
| ---------- | --------- |
| id         | UUID (PK) |
| user\_id   | FK        |
| pdf\_url   | Text      |
| cert\_hash | Text      |
| cert\_type | Enum      |
| issued\_at | Timestamp |

---

## ✅ 4. Verification Page `/verify?cid=...`

This route:

* Takes `cert_hash`
* Looks it up in Supabase
* Displays: PDF URL + metadata (user name, type, date)

```ts
const { data } = await supabase
  .from("certificates")
  .select("*")
  .eq("cert_hash", cid)
  .single();
```

---

## 🧠 FLOW SUMMARY

| Trigger                                  | Result                             |
| ---------------------------------------- | ---------------------------------- |
| Final task complete OR payment confirmed | `/api/genCert?email=...` is called |
| Certificate is generated + stored        | PDF saved in Supabase              |
| Cert link is returned                    | `/verify?cid=...` hash-based URL   |
| Verifier can check PDF + metadata        | ✅ Transparent & secure             |

---

## 🛡️ BONUS: Dynamic Badge Logic

To show the "Best Performer" ribbon:

* Use `user.is_best_performer === true`
* Select the best-performer template dynamically

---

## ✅ FINAL RESULT

* Fully branded certs
* Automated generation
* Hosted securely
* Verifiable publicly
* Zero human interaction needed

---
